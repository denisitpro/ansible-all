#!/bin/bash

# Backup script generated by Ansible
# Usage: backup-directory.sh --source <path> --dest <path> [options]

set -euo pipefail

# Default configuration
DEFAULT_DEST_DIR="{{ backup_dest_dir }}"
DEFAULT_RAGE_RECIPIENT="{{ backup_rage_recipient }}"
DEFAULT_RETENTION_DAYS="{{ backup_retention_days }}"
DEFAULT_FILENAME_PREFIX="{{ backup_filename_prefix }}"
DEFAULT_LOG_FILE="{{ backup_log_file }}"
DEFAULT_COMPRESS="{{ backup_compress | lower }}"
DEFAULT_ENCRYPT="{{ backup_encrypt | lower }}"
DEFAULT_PACK_FILES="{{ backup_pack_files | lower }}"
DEFAULT_FORCE_REWRITE="{{ backup_force_rewrite | lower }}"

# Initialize variables
SOURCE_DIR=""
DEST_DIR="$DEFAULT_DEST_DIR"
RAGE_RECIPIENT="$DEFAULT_RAGE_RECIPIENT"
RETENTION_DAYS="$DEFAULT_RETENTION_DAYS"
FILENAME_PREFIX="$DEFAULT_FILENAME_PREFIX"
LOG_FILE="$DEFAULT_LOG_FILE"
COMPRESS="$DEFAULT_COMPRESS"
ENCRYPT="$DEFAULT_ENCRYPT"
PACK_FILES="$DEFAULT_PACK_FILES"
FORCE_REWRITE="$DEFAULT_FORCE_REWRITE"

# Show usage information
show_usage() {
    cat << EOF
Usage: $0 --source <source_directory> [options]

Required:
  --source <path>        Source directory to backup

Optional:
  --dest <path>          Destination directory (default: $DEFAULT_DEST_DIR)
  --prefix <string>      Backup filename prefix (default: $DEFAULT_FILENAME_PREFIX)
  --retention <days>     Backup retention in days (default: $DEFAULT_RETENTION_DAYS)
  --rage-recipient <key>  Rage recipient key (default: $DEFAULT_RAGE_RECIPIENT)
  --no-encrypt          Disable rage encryption
  --no-compress         Disable compression
  --no-pack             Disable file packing (encrypt files directly)
  --force-rewrite       Force rewrite existing encrypted files
  --log-file <path>      Log file path (default: $DEFAULT_LOG_FILE)
  --help                Show this help message

Examples:
  $0 --source /opt/backup
  $0 --source /var/log --dest /backup --prefix logs --retention 7
  $0 --source /home/user --no-encrypt --no-compress
  $0 --source /home/user --no-pack --encrypt  # Encrypt files directly without packing
EOF
}

# Parse command line arguments
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --source)
                SOURCE_DIR="$2"
                shift 2
                ;;
            --dest)
                DEST_DIR="$2"
                shift 2
                ;;
            --prefix)
                FILENAME_PREFIX="$2"
                shift 2
                ;;
            --retention)
                RETENTION_DAYS="$2"
                shift 2
                ;;
            --rage-recipient)
                RAGE_RECIPIENT="$2"
                shift 2
                ;;
            --no-encrypt)
                ENCRYPT="false"
                shift
                ;;
            --no-compress)
                COMPRESS="false"
                shift
                ;;
            --no-pack)
                PACK_FILES="false"
                shift
                ;;
            --force-rewrite)
                FORCE_REWRITE="true"
                shift
                ;;
            --log-file)
                LOG_FILE="$2"
                shift 2
                ;;
            --help)
                show_usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
}

# Validate arguments
validate_arguments() {
    if [[ -z "$SOURCE_DIR" ]]; then
        echo "Error: --source parameter is required"
        show_usage
        exit 1
    fi
    
    if [[ ! -d "$SOURCE_DIR" ]]; then
        error_exit "Source directory does not exist: $SOURCE_DIR"
    fi
    
    if [[ ! "$RETENTION_DAYS" =~ ^[0-9]+$ ]]; then
        error_exit "Retention days must be a positive number: $RETENTION_DAYS"
    fi
}

# Logging function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [$$] $1" | tee -a "$LOG_FILE"
}

# Error handling
error_exit() {
    log "ERROR: $1"
    exit 1
}

# Parse command line arguments
parse_arguments "$@"

# Validate arguments
validate_arguments

# Create destination directory if it doesn't exist
mkdir -p "$DEST_DIR"

# Generate timestamp
TIMESTAMP=$(date +%Y%m%d_%H%M%S)

# Define backup filename
if [ "$PACK_FILES" = "true" ]; then
    if [ "$ENCRYPT" = "true" ]; then
        BACKUP_FILE="${DEST_DIR}/${FILENAME_PREFIX}_${TIMESTAMP}.tar.gz.age"
    else
        BACKUP_FILE="${DEST_DIR}/${FILENAME_PREFIX}_${TIMESTAMP}.tar.gz"
    fi
else
    if [ "$ENCRYPT" = "true" ]; then
        # For directory encryption, we'll encrypt files directly to destination
        BACKUP_DIR="$DEST_DIR"
    else
        error_exit "Cannot create backup without packing or encryption"
    fi
fi

log "Starting backup of $SOURCE_DIR"
if [ "$PACK_FILES" = "true" ]; then
    log "Backup file: $BACKUP_FILE"
else
    log "Backup directory: $BACKUP_DIR"
fi

# Create backup
if [ "$PACK_FILES" = "true" ]; then
    # Pack files into archive
    if [ "$ENCRYPT" = "true" ]; then
        # Encrypted packed backup
        if [ "$COMPRESS" = "true" ]; then
            tar -czf - -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")" | \
            rage -r "$RAGE_RECIPIENT" -o "$BACKUP_FILE"
        else
            tar -cf - -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")" | \
            rage -r "$RAGE_RECIPIENT" -o "$BACKUP_FILE"
        fi
    else
        # Unencrypted packed backup
        if [ "$COMPRESS" = "true" ]; then
            tar -czf "$BACKUP_FILE" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"
        else
            tar -cf "$BACKUP_FILE" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"
        fi
    fi
else
    # Direct file encryption without packing
    if [ "$ENCRYPT" = "true" ]; then
        log "Encrypting files directly without packing"
        
        # Create backup directory
        mkdir -p "$BACKUP_DIR"
        
        # Function to encrypt files recursively
        encrypt_directory() {
            local source_path="$1"
            local dest_path="$2"
            
            # Create destination directory
            mkdir -p "$dest_path"
            
            # Process all items in source directory
            for item in "$source_path"/*; do
                if [ -d "$item" ]; then
                    # Recursively process subdirectories
                    local subdir_name=$(basename "$item")
                    encrypt_directory "$item" "$dest_path/$subdir_name"
                elif [ -f "$item" ]; then
                    # Encrypt individual files
                    local filename=$(basename "$item")
                    local encrypted_file="$dest_path/$filename.age"
                    
                    # Check if encrypted file already exists
                    if [ -f "$encrypted_file" ] && [ "$FORCE_REWRITE" != "true" ]; then
                        log "Skipping existing encrypted file: $encrypted_file"
                    else
                        log "Encrypting file: $item -> $encrypted_file"
                        rage -r "$RAGE_RECIPIENT" -o "$encrypted_file" "$item"
                    fi
                fi
            done
        }
        
        # Start encryption process
        encrypt_directory "$SOURCE_DIR" "$BACKUP_DIR/$(basename "$SOURCE_DIR")"
        
        log "Directory encryption completed. Encrypted files in: $BACKUP_DIR"
    else
        error_exit "Cannot create backup without packing or encryption"
    fi
fi

# Check if backup was created successfully
if [ "$PACK_FILES" = "true" ]; then
    if [ -f "$BACKUP_FILE" ]; then
        BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
        log "Backup completed successfully. Size: $BACKUP_SIZE"
    else
        error_exit "Backup failed - file was not created"
    fi
else
    if [ -d "$BACKUP_DIR" ]; then
        BACKUP_SIZE=$(du -sh "$BACKUP_DIR" | cut -f1)
        ENCRYPTED_FILES=$(find "$BACKUP_DIR" -name "*.age" | wc -l)
        log "Directory encryption completed successfully. Size: $BACKUP_SIZE, Encrypted files: $ENCRYPTED_FILES"
    else
        error_exit "Directory encryption failed - directory was not created"
    fi
fi

# Cleanup old backups
log "Cleaning up backups older than $RETENTION_DAYS days"
if [ "$PACK_FILES" = "true" ]; then
    # Cleanup packed backups
    find "$DEST_DIR" -name "${FILENAME_PREFIX}_*.tar.gz*" -type f -mtime +$RETENTION_DAYS -delete
    REMAINING_COUNT=$(find "$DEST_DIR" -name "${FILENAME_PREFIX}_*.tar.gz*" -type f | wc -l)
else
    # Cleanup encrypted directories and files
    find "$DEST_DIR" -name "${FILENAME_PREFIX}_*_encrypted" -type d -mtime +$RETENTION_DAYS -exec rm -rf {} +
    find "$DEST_DIR" -name "*.age" -type f -mtime +$RETENTION_DAYS -delete
    REMAINING_DIRS=$(find "$DEST_DIR" -name "${FILENAME_PREFIX}_*_encrypted" -type d | wc -l)
    REMAINING_FILES=$(find "$DEST_DIR" -name "*.age" -type f | wc -l)
    REMAINING_COUNT=$((REMAINING_DIRS + REMAINING_FILES))
fi
log "Cleanup completed. Remaining backup items: $REMAINING_COUNT"

log "Backup process finished successfully"
