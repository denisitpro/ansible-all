prometheus:
{% if k8s_prometheus_annotations is defined or k8s_prometheus_labels is defined %}
  service:
{% if k8s_prometheus_annotations is defined %}
    annotations:
{% for k, v in k8s_prometheus_annotations.items() %}
{% if '\n' in v %}
      {{ k }}: |
{% for line in v.splitlines() %}
        {{ line }}
{% endfor %}
{% else %}
      {{ k }}: "{{ v }}"
{% endif %}
{% endfor %}
{% endif %}
{% if k8s_prometheus_labels is defined %}
    labels:
{% for k, v in k8s_prometheus_labels.items() %}
      {{ k }}: "{{ v }}"
{% endfor %}
{% endif %}
{% endif %}
  prometheusSpec:
    retention: 2d
    retentionSize: 18GB
    enableFeatures: ["exemplar-storage"]
    serviceDiscoveryRole: "EndpointSlice"
{% if k8s_prometheus_external_labels is defined %}
    externalLabels:
{% for k, v in k8s_prometheus_external_labels.items() %}
      {{ k }}: "{{ v }}"
{% endfor %}
{% endif %}
{% if k8s_prom_pvc_enable is defined %}
    storageSpec:
      volumeClaimTemplate:
        spec:
          # storageClassName: {{ prometheus_storage_class | default("standard") }}
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: {{ k8s_prometheus_storage_size | default("20Gi") }}
{% endif %}
{% set remote_write_config = k8s_prom_remote_write | default([]) %}
{% if remote_write_config | length > 0 %}
    volumes:
{% for remote in remote_write_config %}
{% if remote.remote_write.secret_type == 'mtls' %}
      - name: {{ remote.remote_write.secret_name }}-secret
        secret:
          secretName: {{ remote.remote_write.secret_name }}
{% endif %}
{% endfor %}
    volumeMounts:
{% for remote in remote_write_config %}
{% if remote.remote_write.secret_type == 'mtls' %}
      - name: {{ remote.remote_write.secret_name }}-secret
        mountPath: /etc/prometheus/secrets/{{ remote.remote_write.secret_name }}
        readOnly: true
{% endif %}
{% endfor %}
{% endif %}
{% set remote_write_config = k8s_prom_remote_write | default([]) %}
{% if remote_write_config | length > 0 %}
    remoteWrite:
{% for remote in remote_write_config %}
      - url: {{ remote.remote_write.url }}
        enableHTTP2: true
{% if remote.remote_write.protobuf_message is defined %}
        messageVersion: "V2.0"
{% endif %}
{% if remote.remote_write.send_exemplars is defined and remote.remote_write.send_exemplars %}
        sendExemplars: true
{% endif %}
{% if remote.remote_write.secret_type == 'mtls' %}
        tlsConfig:
          caFile: /etc/prometheus/secrets/{{ remote.remote_write.secret_name }}/cacert
          certFile: /etc/prometheus/secrets/{{ remote.remote_write.secret_name }}/client.crt
          keyFile: /etc/prometheus/secrets/{{ remote.remote_write.secret_name }}/client.key
{% if remote.remote_write.tls_config.insecure_skip_verify is defined and remote.remote_write.tls_config.insecure_skip_verify %}
          insecureSkipVerify: true
{% endif %}
{% endif %}
{% if remote.remote_write.secret_type == 'http-basic' %}
        basicAuth:
          username:
            name: {{ remote.remote_write.secret_name }}
            key: username
          password:
            name: {{ remote.remote_write.secret_name }}
            key: password
{% endif %}
{% if remote.remote_write.queue_config is defined %}
        queueConfig:
          batchSendDeadline: {{ remote.remote_write.queue_config.batch_send_deadline | default("5s") }}
          maxSamplesPerSend: {{ remote.remote_write.queue_config.max_samples_per_send | default(1000) }}
          maxShards: {{ remote.remote_write.queue_config.max_shards | default(5) }}
{% endif %}
{% endfor %}
{% endif %}
    podMonitorSelector:
      matchLabels: {}
    additionalScrapeConfigs:
      - job_name: 'applications-monitor'
        kubernetes_sd_configs:
          - role: endpoints
            namespaces:
              names: []
        relabel_configs:
          - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scrape]
            action: keep
            regex: (?i)true
          - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__meta_kubernetes_service_annotation_prometheus_io_scheme]
            action: replace
            target_label: __scheme__
            regex: (https?)
          - source_labels: [__address__, __meta_kubernetes_service_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: $1:$2
            target_label: __address__
          - action: labelmap
            regex: __meta_kubernetes_service_label_(.+)
          - source_labels: [__meta_kubernetes_namespace]
            action: replace
            target_label: namespace
          - source_labels: [__meta_kubernetes_service_name]
            action: replace
            target_label: service
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: pod
          - source_labels: [__meta_kubernetes_pod_container_name]
            action: replace
            target_label: container
{% if k8s_prometheus_external_labels is defined and k8s_prometheus_external_labels.cluster is defined %}
          - target_label: cluster
            replacement: {{ k8s_prometheus_external_labels.cluster }}
{% endif %}
        scrape_interval: 30s
        scrape_timeout: 10s
{% if k8s_pod_monitoring_enabled is defined and k8s_pod_monitoring_enabled %}
      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
{% if k8s_pod_monitoring_config is defined and k8s_pod_monitoring_config.selector is defined %}
          # Use custom selector configuration
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: (?i){{ k8s_pod_monitoring_config.selector.matchLabels['prometheus.io/scrape'] | default('true') }}
{% else %}
          # Example: collect metrics only from pods with prometheus.io/scrape=true annotation
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: (?i)true
          - source_labels: [__meta_kubernetes_pod_phase]
            action: drop
            regex: (Failed|Succeeded)
{% endif %}
          # Use annotation to specify metrics path (e.g., /metrics)
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scheme]
            action: replace
            target_label: __scheme__
            regex: (https?)
          # Fallback: Use named container port if annotation port is not set
          - source_labels: [__address__, __meta_kubernetes_pod_container_port_name]
            action: replace
            regex: ([^:]+)(?::\d+)?;metrics
            replacement: $1:{{ k8s_pod_monitoring_default_port | default(8080) }}
            target_label: __address__
          # Use annotation to specify port
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: $1:$2
            target_label: __address__
          - source_labels: [__address__]
            action: replace
            target_label: instance
          # Assign meaningful name to pod in Prometheus
          - action: labelmap
            regex: __meta_kubernetes_pod_label_(.+)
          - source_labels: [__meta_kubernetes_namespace]
            action: replace
            target_label: namespace
          - source_labels: [__meta_kubernetes_pod_name]
            action: replace
            target_label: pod
          - source_labels: [__meta_kubernetes_pod_container_name]
            action: replace
            target_label: container
{% if k8s_prometheus_external_labels is defined and k8s_prometheus_external_labels.cluster is defined %}
          - target_label: cluster
            replacement: {{ k8s_prometheus_external_labels.cluster }}
{% endif %}
        scrape_interval: 30s
        scrape_timeout: 10s
{% endif %}


nodeExporter:
  enabled: false

kubeStateMetrics:
  enabled: true

alertmanager:
  enabled: false

grafana:
  enabled: true
{% if k8s_grafana_annotations is defined or k8s_grafana_labels is defined %}
  service:
{% if k8s_grafana_annotations is defined %}
    annotations:
{% for k, v in k8s_grafana_annotations.items() %}
{% if '\n' in v %}
      {{ k }}: |
{% for line in v.splitlines() %}
        {{ line }}
{% endfor %}
{% else %}
      {{ k }}: "{{ v }}"
{% endif %}
{% endfor %}
{% endif %}
{% if k8s_grafana_labels is defined %}
    labels:
{% for k, v in k8s_grafana_labels.items() %}
      {{ k }}: "{{ v }}"
{% endfor %}
{% endif %}
{% endif %}

kubeProxy:
  enabled: false

kubeControllerManager:
  enabled: false
#   service:
#     enabled: true
#     port: null
#     targetPort: null
#     ipDualStack:
#       enabled: false
#       ipFamilies: [ "IPv4"]
#       ipFamilyPolicy: "SingleStack"
#     selector:
#       component: kube-controller-manager
kubeEtcd:
  enabled: false
#   service:
#     enabled: true
#     port: 2381
#     targetPort: 2381
#     selector:
#       component: etcd
#   endpoints:
#     - 127.0.0.1
#   tls:
#     enabled: true
#     certFile: /etc/kubernetes/pki/etcd/server.crt
#     keyFile: /etc/kubernetes/pki/etcd/server.key
#     caFile: /etc/kubernetes/pki/etcd/ca.crt

kubeScheduler:
  enabled: false
#   endpoints:
#     - 127.0.0.1
#   service:
#     enabled: true
#     port: 10259
#   https:
#     enabled: true 